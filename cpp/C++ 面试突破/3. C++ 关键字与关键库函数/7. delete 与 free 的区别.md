# delete 与 free 的区别

## free 的简介

`free` 释放 `heap` 中申请的动态内存空间，只能释放 `malloc`，`callo`c，`realloc` `申请的内存。需要注意的是，free` 函数只是将参数指针指向的内存归还给操作系统，并不会把参数指针置 `NULL`，为了以后访问到被操作系统重新分配后的错误数据，所以在调用 `free` 之后，通常需要手动将指针置 `NULL`。

内存资源都是由操作系统来管理的，而不是编译器，编译器只是向操作系统提出申请，所以 `free` 函数是没有能力去真正的 `free` 内存的，只是向内存管理模块归还了内存，其他模块还可以继续申请使用这些内存。`free` 后指针仍然指向原来的堆地址，实际还可以使用，但操作系统可能将这块内存已经分配给其他模块使用，一般建议在 `free` 以后将指针置为空。一个指针经过两次 `free`，也是比较危险的操作，因为可能该段内存已被别的内存使用申请使用了，`free` 之后会造成严重后果。

## delete 的简介

`delete` 是 `C++` 中的一个操作符，如果对象存在析构函数，它首先执行该对象所属类的析构函数，进而通过调用 `operator delete` 的标准库函数来释放所占的内存空间。`delete` 用来释放单个对象所占的空间，只会调用一次析构函数；`delete []` 用来释放数组空间，会对数组中的每个元素都调用一次析构函数。

`delete` 只能用来释放 `new` 操作返回的指针，否则会产生不可预知的后果。在单个对象上的删除 使用 `delete []` 的数组形式，以及对数组使用非数组形式的删除都会产生不可预知的后果。如果 `new` 的对象是指定地址，则不能直接调用 `delete`。

## 区别

- `delete` 是 `C++` 中的一个操作符，可以进行重载；而 `free` 是 `C` 中的一个函数，不能进行重载；
- `free` 只会释放指向的内存，不会执行对象的析构函数；`delete` 则可以执行对象的析构函数；

## 参考资料

- [Difference between delete and free() in C++](https://www.includehelp.com/cpp-tutorial/difference-between-delete-and-free.aspx)
