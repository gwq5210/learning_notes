# extern C 的作用

`C` 和 `C++` 对同一个函数经过编译后生成的函数名是不同的，由于 `C++` 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的函数名中，而不仅仅是原始的函数名。比如以下函数，同一个函数 `test` 在 `C++` 编译后符号表中生成的函数名可能为 `_Z4testv`，而 `C` 编译后符号表中生成的函数名可能为 `test`。

比如同一个函数:

```cpp
int test() {
  return 0;
}
```

由于 `C` 语言并不支持函数重载，在 `C` 语言中函数不能重名，因此编译 `C` 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。如果在 `C++` 中调用一个使用 `C` 语言编写的模块中的某个函数 `test`，`C++` 是根据 `C++` 的函数名称修饰方式来查找并链接这个函数，去在生成的符号表查找 `_Z4testv` 这个函数的代码，此时就会发生链接错误。而此时我们用 `extern C` 声明，那么在链接时，`C++` 编译器则按照 `C` 语言的函数命名规则 `test` 去符号表中查找对应的函数。因此当 `C++` 程序需要调用 `C` 语言编写的函数，`C++` 使用链接指示，即 `extern "C"` 指出任意非 `C++` 函数所用的语言。

```cpp
// 可能出现在 C++ 头文件<cstring>中的链接指示
extern "C"{
    int strcmp(const char*, const char*);
}
```

## 参考资料

- [extern (C++)](https://docs.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170)
