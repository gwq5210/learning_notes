# socket可读可写条件

socket可读可写条件，经常做为面试题被问，因为它考察被面试者对网络编程的基础了解的是不是够深入

要了解socket可读可写条件，我们先了解几个概念：

1. 接收缓存区低水位标记（用于读）和发送缓存区低水位标记（用于写）
   1. 每个套接字有一个接收低水位和一个发送低水位。他们由select函数使用。
   2. 接收低水位标记是让select返回"可读"时套接字接收缓冲区中所需的数据量。对于TCP,其默认值为1。
   3. 发送低水位标记是让select返回"可写"时套接字发送缓冲区中所需的可用空间。对于TCP，其默认值常为2048.（也是面试点之一）
   4. 通俗的解释一下，缓存区我们当成一个大小为 n bytes的空间
   5. 接收区缓存的作用就是，接收对面的数据放在缓存区，供应用程序读。当然了，只有当缓存区可读的数据量(接收低水位标记)到达一定程度（eg:1）的时候，我们才能读到数据，不然不就读不到数据了吗。
   6. 发送区缓存的作用就是，发送应用程序的数据到缓存区，然后一起发给对面。当然了，只有当缓存区剩余一定空间(发送低水位标记)（eg:2048）,你才能写数据进去，不然可能导致空间不够。
2. FIN: (结束标志,Finish)用来结束一个TCP回话.但对应端口仍处于开放状态,准备接收后续数据.

## socket可读的条件

下列四个条件中的任何一个满足时,socket准备好读

- socket的接收缓冲区中的数据字节大于等于该socket的接收缓冲区低水位标记的当前大小。对这样的socket的读操作将不阻塞并返回一个大于0的值(也就是返回准备好读入的数据)。我们可以用SO_RCVLOWATsocket选项来设置该socket的低水位标记。对于TCP和UDP socket而言，其缺省值为1.
- 该连接的读这一半关闭(也就是接收了FIN的TCP连接)。对这样的socket的读操作将不阻塞并返回0
- socket是一个用于监听的socket,并且已经完成的连接数为非0.这样的socket处于可读状态,是因为socket收到了对方的connect请求,执行了三次握手的第一步:对方发送SYN请求过来,使监听socket处于可读状态;正常情况下,这样的socket上的accept操作不会阻塞;
- 有一个socket有异常错误条件待处理.对于这样的socket的读操作将不会阻塞,并且返回一个错误(-1),errno则设置成明确的错误条件.这些待处理的错误也可通过指定socket选项SO_ERROR调用getsockopt来取得并清除;

## socket可写的条件

下列三个条件中的任何一个满足时,socket准备好写

- socket的发送缓冲区中的数据字节大于等于该socket的发送缓冲区低水位标记的当前大小。对这样的socket的写操作将不阻塞并返回一个大于0的值(也就是返回准备好写入的数据)。我们可以用SO_SNDLOWAT socket选项来设置该socket的低水位标记。对于TCP和UDP socket而言，其缺省值为2048
- 该连接的写这一半关闭。对这样的socket的写操作将产生SIGPIPE信号，该信号的缺省行为是终止进程。
- 有一个socket异常错误条件待处理.对于这样的socket的写操作将不会阻塞并且返回一个错误(-1),errno则设置成明确的错误条件.这些待处理的错误也可以通过指定socket选项SO_ERROR调用getsockopt函数来取得并清除;

解释一下连接的读/写这一半关闭

![tcp-半关闭](images/tcp-%E5%8D%8A%E5%85%B3%E9%97%AD.png)

终止一个连接需要4个分节，主动关闭的一端（A）调用close发送FIN到另一端（B），B接收到FIN后，知道A已经主动关闭了，也就是，A不会发数据来了，那么这一端调用read必然可读，且返回0(read returns 0).

## 参考

- [socket可读可写条件](https://blog.csdn.net/majianfei1023/article/details/45788591)
