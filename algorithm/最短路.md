# 最短路

## 定义

（还记得这些定义吗？在阅读下列内容之前，请务必了解 图论相关概念 中的基础部分。）

- 路径
- 最短路
- 有向图中的最短路、无向图中的最短路
- 单源最短路、每对结点之间的最短路

## 性质

- 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。
- 对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。
- 对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过 n，边数不会超过 n-1。

## 记号

为了方便叙述，这里先给出下文将会用到的一些记号的含义。

- n 为图上点的数目，m 为图上边的数目；
- s 为最短路的源点；
- D(u) 为 s 点到 u 点的 实际 最短路长度；
- dis(u) 为 s 点到 u 点的 估计 最短路长度。任何时候都有 dis(u) $\geq$ D(u)。特别地，当最短路算法终止时，应有 dis(u)=D(u)。
- w(u,v) 为 (u,v) 这一条边的边权。

## Floyd 算法

## Bellman-Ford 算法

## Dijkstra 算法

Dijkstra（/ˈdikstrɑ/或/ˈdɛikstrɑ/）算法由荷兰计算机科学家 E. W. Dijkstra 于 1956 年发现，1959 年公开发表。是一种求解 非负权图 上单源最短路径的算法。

### 过程

将结点分成两个集合：已确定最短路长度的点集（记为 S 集合）的和未确定最短路长度的点集（记为 T 集合）。一开始所有的点都属于 T 集合。

初始化 `dis(s)=0`，其他点的 `dis` 均为 $+\infty$。

然后重复这些操作：

- 从 T 集合中，选取一个最短路长度最小的结点，移到 S 集合中。
- 对那些刚刚被加入 S 集合的结点的所有出边执行松弛操作。

直到 T 集合为空，算法结束。

### 时间复杂度

有多种方法来维护 `1` 操作中最短路长度最小的结点，不同的实现导致了 `Dijkstra` 算法时间复杂度上的差异。

- 暴力：不使用任何数据结构进行维护，每次 2 操作执行完毕后，直接在 T 集合中暴力寻找最短路长度最小的结点。2 操作总时间复杂度为 O(m)，1 操作总时间复杂度为 O($n^2$)，全过程的时间复杂度为 O($n^2 + m$) = O($n^2$)。
- 二叉堆：每成功松弛一条边 (u,v)，就将 v 插入二叉堆中（如果 v 已经在二叉堆中，直接修改相应元素的权值即可），1 操作直接取堆顶结点即可。共计 O(m) 次二叉堆上的插入（修改）操作，O(n) 次删除堆顶操作，而插入（修改）和删除的时间复杂度均为 O($\log n$)，时间复杂度为 O($(n+m) \log n$) = O($m \log n$)。
- 优先队列：和二叉堆类似，但使用优先队列时，如果同一个点的最短路被更新多次，因为先前更新时插入的元素不能被删除，也不能被修改，只能留在优先队列中，故优先队列内的元素个数是 O(m) 的，时间复杂度为 O($m \log m$)。

在稀疏图中，m = O(n)，使用二叉堆实现的 `Dijkstra` 算法较 `Bellman-Ford` 算法具有较大的效率优势；而在稠密图中，m = O($n^2$)，这时候使用暴力做法较二叉堆实现更优。

### 正确性证明

下面用数学归纳法证明，在 **所有边权值非负** 的前提下，`Dijkstra` 算法的正确性

简单来说，我们要证明的，就是在执行 1 操作时，取出的结点 u 最短路均已经被确定，即满足 `D(u) = dis(u)`。

初始时 S = $\varnothing$，假设成立。

接下来用反证法。

设 `u` 点为算法中第一个在加入 `S` 集合时不满足 `D(u) = dis(u)` 的点。因为 `s` 点一定满足 `D(u)=dis(u)=0`，且它一定是第一个加入 `S` 集合的点，因此将 u 加入 S 集合前，$S \neq \varnothing$，如果不存在 s 到 u 的路径，则 $D(u) = dis(u) = +\infty$，与假设矛盾。

于是一定存在路径 $s \to x \to y \to u$，其中 $y$ 为 $s \to u$ 路径上第一个属于 $T$ 集合的点，而 $x$ 为 $y$ 的前驱结点（显然 $x \in S$）。需要注意的是，可能存在 $s = x$ 或 $y = u$ 的情况，即 $s \to x$ 或 $y \to u$ 可能是空路径。

因为在 $u$ 结点之前加入的结点都满足 $D(u) = dis(u)$，所以在 $x$ 点加入到 $S$ 集合时，有 $D(x) = dis(x)$，此时边 $(x,y)$ 会被松弛，从而可以证明，将 $u$ 加入到 $S$ 时，一定有 $D(y)=dis(y)$。

下面证明 $D(u) = dis(u)$ 成立。在路径 $s \to x \to y \to u$ 中，因为图上所有边边权非负，因此 $D(y) \leq D(u)$。从而 $dis(y) \leq D(y) \leq D(u)\leq dis(u)$。但是因为 $u$ 结点在 1 过程中被取出 $T$ 集合时，$y$ 结点还没有被取出 $T$ 集合，因此此时有 $dis(u)\leq dis(y)$，从而得到 $dis(y) = D(y) = D(u) = dis(u)$，这与 $D(u)\neq dis(u)$ 的假设矛盾，故假设不成立。

因此我们证明了，1 操作每次取出的点，其最短路均已经被确定。命题得证。

注意到证明过程中的关键不等式 $D(y) \leq D(u)$ 是在图上所有边边权非负的情况下得出的。当图上存在负权边时，这一不等式不再成立，Dijkstra 算法的正确性将无法得到保证，算法可能会给出错误的结果。

### 实现

这里同时给出 $O(n^2)$ 的暴力做法实现和 $O(m \log m)$ 的优先队列做法实现。

```cpp
struct edge {
  int v, w;
};

vector<edge> e[maxn];
int dis[maxn], vis[maxn];

void dijkstra(int n, int s) {
  memset(dis, 63, sizeof(dis));
  dis[s] = 0;
  for (int i = 1; i <= n; i++) {
    int u = 0, mind = 0x3f3f3f3f;
    for (int j = 1; j <= n; j++)
      if (!vis[j] && dis[j] < mind) u = j, mind = dis[j];
    vis[u] = true;
    for (auto ed : e[u]) {
      int v = ed.v, w = ed.w;
      if (dis[v] > dis[u] + w) dis[v] = dis[u] + w;
    }
  }
}
```

```cpp
struct edge {
  int v, w;
};

struct node {
  int dis, u;

  bool operator>(const node& a) const { return dis > a.dis; }
};

vector<edge> e[maxn];
int dis[maxn], vis[maxn];
priority_queue<node, vector<node>, greater<node> > q;

void dijkstra(int n, int s) {
  // dis[s]初始化为0，其他值初始化为INF
  memset(dis, 63, sizeof(dis));
  dis[s] = 0;
  // 优先队列中保存的是集合T的节点
  q.push({0, s});
  while (!q.empty()) {
    // 从优先队列中取出的最短路长度最小的结点u
    // 第一次取出时, 已经是最短路了，即D(u) = dis(u)
    // 第一次取出时, 使用vis数组进行标记，后续遇到直接跳过
    // 即vis数组中的值为1的节点是集合S的节点
    int u = q.top().u;
    q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (auto ed : e[u]) {
      int v = ed.v, w = ed.w;
      // 如果从u到v的距离比现在的dis[v]更短，才需要加入优先队列中，并且更新dis[v]
      if (dis[v] > dis[u] + w) {
        dis[v] = dis[u] + w;
        q.push({dis[v], v});
      }
    }
  }
}
```

### 优先队列BFS

优先队列，相当于一个二叉堆，`STL` 中提供了 `std::priority_queue`，可以方便我们使用优先队列。

在基于优先队列的 `BFS` 中，我们每次从队首取出代价最小的结点进行进一步搜索。容易证明这个贪心思想是正确的，因为从这个结点开始扩展的搜索，一定不会更新原来那些代价更高的结点。换句话说，其余那些代价更高的结点，我们不回去考虑更新它。

当然，每个结点可能会被入队多次，只是每次入队的代价不同。当该结点第一次从优先队列中取出，以后便无需再在该结点进行搜索，直接忽略即可。所以，优先队列的 `BFS` 当中，每个结点只会被处理一次。

相对于普通队列的 `BFS`，时间复杂度多了一个 $\log n$，毕竟要维护这个优先队列嘛。不过普通 `BFS` 有可能每个结点入队、出队多次，时间复杂度会达到 $O(n^2)$，不是 $O(n)$。所以优先队列 `BFS` 通常还是快的。

诶？这怎么听起来这么像堆优化的 `Dijkstra` 算法呢？事实上，堆优化 `Dijkstra` 就是优先队列 `BFS`。

## 题目

- [787. K站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/description/)

## 参考资料

- [最短路](https://oi-wiki.org/graph/shortest-path/)
