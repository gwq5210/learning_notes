- [第十一章 线程](#第十一章-线程)
  - [线程概念](#线程概念)
  - [线程标识](#线程标识)
  - [线程创建](#线程创建)
  - [线程终止](#线程终止)

# 第十一章 线程

## 线程概念

典型的UNIX进程可以看成只有一个控制进程：一个进程在某一时刻只能做一件事情。有了多个控制线程以后，在程序设计时就可以把进程设计成在某一时刻能够做不止一件事，每个线程处理各自独立的任务。其好处如下

- 通过为每种事件类型分配单独的处理线程，可以简化处理异步时间的代码。每个线程会采用同步编程模式，其比异步编程模式简单得多
- 多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动的可以访问相同的存储地址和文件描述符
- 有些问题可以分解而提高整个程序吞吐量。当然只有在两个任务的处理过程互不依赖的情况下，两个任务才可以较差运行
- 交互程序同样可以使用多线程来改善响应时间，多线程可以把程序中处理用户输入输出的部分与其他部分分开

有些人把多线程的程序设计与多处理器或多核系统联系起来。但是即使程序运行在单处理器上也能得到多线程编程模型的好处。其并不影响程序结构。程序都可以通过使用线程得以简化。

每个线程都包含有表示执行环境所必须的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符

## 线程标识

每个线程有一个线程ID。进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义

与pid_t是一个非负整数不同。线程ID是用pthread_t数据类型表示的，实现的时候可以用一个结构来代表，所以可移植的实现不能把它作为整数处理。因此必须使用一个函数来对两个线程ID进行比较

```cpp
#include <pthread.h>

int pthread_equal(pthread_t tid1, pthread_t tid2);

若相等，返回非0数值；否则，返回0
```

无法用可移植的方法打印pthread_t的值，但线程ID通常在调试过程中需要打印

线程可以通过调用pthread_self函数获得自身的线程ID

```cpp
#include <pthread.h>

pthread_t pthread_self(void);

返回调用线程的线程ID
```

## 线程创建

在传统的UNIX进程模型中，每个进程只有一个控制线程。从概念上讲，这与基于线程模型中每个进程只包含一个线程是相同的。在pthread的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。新增的线程可以通过调用pthread_create函数创建

```cpp
#include <pthread.h>

int pthread_create(pthread_t* restrict tidp, const pthread_attr_t* restrict attr, void* (*start_rtn)(void*), void* restrict arg);

若成功，返回0；否则返回错误编号
```

attr参数用于定制各种不同的线程属性。为NULL时创建一个具有默认属性的线程。新创建的线程从start_rtn函数的地址开始运行，参数为arg

线程创建时并不能保证哪个线程会先运行：是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并继承调用线程浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除

注意pthread函数在调用失败时，通常会返回错误码，并不设置errno。每个线程提供errno的副本，这只是为了与使用errno的现有函数兼容。在线程中，从函数中返回错误码更清晰整洁，不需要依赖那些随着函数执行不断变化的全局状态，这样可以把错误范围限制在出错的函数中

pthread_create虽然会返回新线程ID，但是新建的线程并不能安全的使用它，如果新线程在主线程调用pthread_create返回之前就运行了，那么新线程看到的是未初始化的tidp内容，这个内容并不是正确的线程ID

## 线程终止

如果进程中的任意线程调用了exit、_Exit或_exit，那么整个进程就会终止。与此相似，如果默认的动作是终止进程，那么发送到线程的信号就会终止整个进程

单个线程有3中方式退出，因此可以在不终止整个进程的情况下，停止它的控制流

- 线程可以简单的从启动例程中返回，返回值是线程的退出码
- 线程可以被同一进程中的其他线程取消
- 线程调用pthread_exit

```cpp
#include <pthread.h>

void pthread_exit(void* rval_ptr);
```

进程中的线程可以通过调用pthread_join函数访问到退出指针

```cpp
#include <pthread.h>

int pthread_join(pthread_t thread, void** rval_ptr);

若成功，返回0；否则，返回错误编码
```

调用线程将一直阻塞，直到指定的线程退出。如果线程简单的从它的启动例程中返回，rval_ptr就包含了返回码。如果线程被取消，由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED

可以通过调用pthread_detach自动把线程置于分离状态，这样资源就可以恢复。如果线程已处理分离状态，pthread_join调用就会失败，返回EINVAL，尽管这种行为是与具体实现相关的

如果对线程的返回值不感兴趣，可以将rval_ptr设置为NULL

